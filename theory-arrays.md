### Массивы

#### Что такое массив
Массив - это коллекция элементов **одного типа**, хранящихся в **непрерывной** области памяти и доступных по **индексу**.

Массивы позволяют хранить **последовательность** данных **одного и того же типа** под одним общим именем. Думайте о массиве как о ряде почтовых ящиков, каждый из которых может хранить только письма (например, целые числа), и все ящики пронумерованы, начиная с нуля.

Индексация элементов массива **всегда начинается с 0**. Если массив имеет размер $N$, то допустимые индексы от $0$ до $N-1$.

#### Организация массива в памяти
Элементы массива хранятся в **смежных** (непрерывных) ячейках памяти. Если Вы объявляете массив из 5 целых чисел (`int`), то в памяти под эти числа будет выделен один цельный блок.

Благодаря непрерывному хранению, зная адрес первого элемента массива (с индексом 0), компилятор может очень быстро вычислить адрес любого другого элемента. Например, адрес элемента с индексом $i$ вычисляется как:

$$\text{Адрес}(A[i]) = \text{Адрес}(A[0]) + i \cdot \text{размер\_типа}$$

где $\text{размер\_типа}$ - это количество байт, занимаемое одним элементом (например, 4 байта для `int`). Это делает доступ к элементам массива очень быстрым.

#### Статическое объявление массива в программе
Это самый простой способ. Размер массива должен быть **константой**, известной на этапе компиляции. Память под такой массив выделяется автоматически при входе в блок, где он объявлен.

Синтаксис объявления массива:
```
тип имя_массива[размер];
```

Пример объявления массива из 5-ти целых чисел:
```C
// Объявление
int numbers[5];

// Доступ и присвоение
numbers[0] = 10;
numbers[4] = 99; // Последний элемент
// numbers[5] = 100; // Ошибка! Выход за границы!

// Вывод второго элемента массива    
printf("The second element of numbers array: %.2f\n", numbers[1]);
}
```

Пример объявления массива из 3-х вещественных чисел с инициализацией:
```C
// Инициализация при объявлении
float prices[] = {19.99, 25.50, 5.00}; // Размер будет 3, определится автоматически
```

#### Динамическое объявление массива в программе
Иногда размер массива неизвестен до момента выполнения программы (например, его вводит пользователь). В этом случае нужно использовать **динамическое выделение памяти** с помощью функции из стандартной библиотеки `<stdlib.h>` - `malloc` (memory allocation). Память выделяется в области, называемой **кучей (heap)**.

Функция `malloc`  делает следующее:
1. Запрос: Вы просите систему выделить блок памяти определённого размера в байтах. Чтобы найти нужный размер, Вы умножаете количество элементов на размер одного элемента (с помощью оператора `sizeof`).
2. Выделение: если память есть, `malloc` выделяет её и возвращает указатель на начало этого блока. Если память выделить не удалось (например, её нет), `malloc` возвращает специальное значение `NULL`.
3. Освобождение: после того как массив больше не нужен, Вы обязаны вернуть выделенную память системе, используя функцию `free`. Это критически важно для предотвращения утечек памяти.

Синтаксис динамического выделения памяти для массива с использованием функции `malloc`:
```
тип* имя_указателя = (тип*)malloc(количество_элементов * sizeof(тип));
```

Пример динамического выделения памяти для массива с использованием функции `malloc`:
```C
#include <stdio.h>
#include <stdlib.h> // Обязательно для malloc и free

int main() {
    int array_size;

	// Ввод размера массива
    printf("Enter size of the array: ");
    scanf("%d", &array_size);

    // Выделение памяти для N целых чисел
    int* dynamic_array = malloc(array_size * sizeof(int));

    // Использование (доступ к элементам через указатель, как к массиву)
    dynamic_array[0] = 50;                  // Первый элемент массива
    dynamic_array[array_size - 1] = 150;    // Последний элемент массива
    
    printf("First element: %d\n", dynamic_array[0]);

    // Освобождение памяти - ОБЯЗАТЕЛЬНО!
    free(dynamic_array);
    dynamic_array = NULL; // Хорошая практика: обнулить указатель
    
    return 0;
}
```

#### Пример решения задачи с использованием массивов
**Задача:** Найти максимальный элемент и поменять его местами с предпоследним.

```C
#include <stdio.h>
#include <stdlib.h>

int main() {
    int array_size;    // Размер массива

    // Ввод размера массива
    printf("Enter the size of the array (> 1): ");
    scanf("%d", &array_size);

    // Проверка, что введенное значение удолетворяет условию
    if (array_size < 2) {
        printf("Size of the array should be > 1");
        return 1;
    }

    // Динамическое выделение памяти для массива
    int *array = malloc(array_size * sizeof(int));

    // Ввод элементов массива
    printf("Enter the array elements:\n");
    for (int i = 0; i < array_size; i++)
    {
        printf("array[%d] = : ", i);
        scanf("%d", &array[i]);
    }

    // Вывод элементов массива
    printf("Array elements:\n");
    for (int i = 0; i < array_size; i++) {
        printf("array[%d] = %d\n", i, array[i]);
    }

    // Объявление переменной, хранящей максимальное
    // значение массива. Для начала считаем, что
    // максимальный элемент стоит на первой позиции
    // в массиве
    int max_element_index = 0;
    int max_element_value = array[0];

    // Поиск максимального элемента в массиве
    for (int i = 1; i < array_size; i++) {
        if (array[i] > max_element_value) {
            max_element_value = array[i];
            max_element_index = i;
        }
    }

    // Вывод максимального элемента и его индекса в массиве
    printf("Max element found: value is %d on position %d\n", max_element_value, max_element_index);

    // Выполняем перестановку: меняем максимальный элемент с предпоследним
    int tmp = array[array_size - 2];            // Записываем в переменную-буфер предпоследний элемент
    array[array_size - 2] = max_element_value;  // Записываем максимальный элемент на предпоследнюю позицию
    array[max_element_index] = tmp;             // Записываем предпоследний элемент на позицию максимального элемента

    // Вывод преобразованного массива
    printf("Elements of the array after swap:\n");
    for (int i = 0; i < array_size; i++) {
        printf("array[%d] = %d\n", i, array[i]);
    }

    // Освобождение выделенной ранее памяти
    free(array);

    return 0;
}
```