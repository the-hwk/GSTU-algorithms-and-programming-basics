### Массивы

#### Что такое массив
Массив - это коллекция элементов **одного типа**, хранящихся в **непрерывной** области памяти и доступных по **индексу**.

Массивы позволяют хранить **последовательность** данных **одного и того же типа** под одним общим именем. Думайте о массиве как о ряде почтовых ящиков, каждый из которых может хранить только письма (например, целые числа), и все ящики пронумерованы, начиная с нуля.

Индексация элементов массива **всегда начинается с 0**. Если массив имеет размер $N$, то допустимые индексы от $0$ до $N-1$.

#### Организация массива в памяти
Элементы массива хранятся в **смежных** (непрерывных) ячейках памяти. Если Вы объявляете массив из 5 целых чисел (`int`), то в памяти под эти числа будет выделен один цельный блок.

Благодаря непрерывному хранению, зная адрес первого элемента массива (с индексом 0), компилятор может очень быстро вычислить адрес любого другого элемента. Например, адрес элемента с индексом $i$ вычисляется как: `Адрес(A[i]) = Адрес(A[0]) + i * размер_типа`, где `размер_типа` - это количество байт, занимаемое одним элементом (например, 4 байта для `int`).

#### Статическое объявление массива в программе
Это самый простой способ. Размер массива должен быть **константой**, известной на этапе компиляции. Память под такой массив выделяется автоматически при входе в блок, где он объявлен.

Синтаксис объявления массива:
```
тип имя_массива[размер];
```

Пример объявления массива из 5-ти целых чисел:
```C
// Объявление
int numbers[5];

// Доступ и присвоение
numbers[0] = 10;
numbers[4] = 99; // Последний элемент
// numbers[5] = 100; // Ошибка! Выход за границы!

// Вывод второго элемента массива    
printf("The second element of numbers array: %.2f\n", numbers[1]);
}
```

Пример объявления массива из 3-х вещественных чисел с инициализацией:
```C
// Инициализация при объявлении
float prices[] = {19.99, 25.50, 5.00}; // Размер будет 3, определится автоматически
```

#### Динамическое объявление массива в программе
Иногда размер массива неизвестен до момента выполнения программы (например, его вводит пользователь). В этом случае нужно использовать **динамическое выделение памяти** с помощью функции из стандартной библиотеки `<stdlib.h>` - `malloc` (memory allocation). Память выделяется в области, называемой **кучей (heap)**.

Функция `malloc`  делает следующее:
1. Запрос: Вы просите систему выделить блок памяти определённого размера в байтах. Чтобы найти нужный размер, Вы умножаете количество элементов на размер одного элемента (с помощью оператора `sizeof`).
2. Выделение: если память есть, `malloc` выделяет её и возвращает указатель на начало этого блока. Если память выделить не удалось (например, её нет), `malloc` возвращает специальное значение `NULL`.
3. Освобождение: после того как массив больше не нужен, Вы обязаны вернуть выделенную память системе, используя функцию `free`. Это критически важно для предотвращения утечек памяти.

Синтаксис динамического выделения памяти для массива с использованием функции `malloc`:
```
тип* имя_указателя = (тип*)malloc(количество_элементов * sizeof(тип));
```

Пример динамического выделения памяти для массива с использованием функции `malloc`:
```C
#include <stdio.h>
#include <stdlib.h> // Обязательно для malloc и free

int main() {
    int array_size;

	// Ввод размера массива
    printf("Enter size of the array: ");
    scanf("%d", &array_size);

    // Динамическое выделение памяти
    int* dynamic_array = malloc(array_size * sizeof(int));

    // Использование (доступ к элементам через указатель, как к массиву)
    dynamic_array[0] = 50;                  // Первый элемент массива
    dynamic_array[array_size - 1] = 150;    // Последний элемент массива
    
    printf("First element: %d\n", dynamic_array[0]);

    // Освобождение памяти - ОБЯЗАТЕЛЬНО!
    free(dynamic_array);
    dynamic_array = NULL; // Хорошая практика: обнулить указатель
    
    return 0;
}
```

#### Пример решения задачи с использованием массивов
**Задача:** Найти максимальный элемент и поменять его местами с предпоследним.

```C
#include <stdio.h>
#include <stdlib.h>

int main() {
    int array_size;    // Размер массива

    // Ввод размера массива
    printf("Enter the size of the array (> 1): ");
    scanf("%d", &array_size);

    // Проверка, что введенное значение удолетворяет условию
    if (array_size < 2) {
        printf("Size of the array should be > 1");
        return 1;
    }

    // Динамическое выделение памяти для массива
    int *array = malloc(array_size * sizeof(int));

    // Ввод элементов массива
    printf("Enter the array elements:\n");
    for (int i = 0; i < array_size; i++)
    {
        printf("array[%d] = : ", i);
        scanf("%d", &array[i]);
    }

    // Вывод элементов массива
    printf("Array elements:\n");
    for (int i = 0; i < array_size; i++) {
        printf("array[%d] = %d\n", i, array[i]);
    }

    // Объявление переменной, хранящей максимальное
    // значение массива. Для начала считаем, что
    // максимальный элемент стоит на первой позиции
    // в массиве
    int max_element_index = 0;
    int max_element_value = array[0];

    // Поиск максимального элемента в массиве
    for (int i = 1; i < array_size; i++) {
        if (array[i] > max_element_value) {
            max_element_value = array[i];
            max_element_index = i;
        }
    }

    // Вывод максимального элемента и его индекса в массиве
    printf("Max element found: value is %d on position %d\n", max_element_value, max_element_index);

    // Выполняем перестановку: меняем максимальный элемент с предпоследним
    int tmp = array[array_size - 2];            // Записываем в переменную-буфер предпоследний элемент
    array[array_size - 2] = max_element_value;  // Записываем максимальный элемент на предпоследнюю позицию
    array[max_element_index] = tmp;             // Записываем предпоследний элемент на позицию максимального элемента

    // Вывод преобразованного массива
    printf("Elements of the array after swap:\n");
    for (int i = 0; i < array_size; i++) {
        printf("array[%d] = %d\n", i, array[i]);
    }

    // Освобождение выделенной ранее памяти
    free(array);

    return 0;
}
```

#### Двумерные массивы (матрица)
Двумерный массив представляет собой массив (назовем его **внешним**), состоящий из массивов (**внутренние**). Объявление двумерного массива выполняется следующим образом:
```C
// Объявление двумерного массива (матрицы)
int matrix[10][5];
```
В первой паре квадратных скобок указывается количество строк матрицы, а во второй - количество столбцов. Другими словами, в первой паре квадратных скобок указывается сколько массивов будет внутри **внешнего** массива, а во второй - размер **внутренних** массивов.

Динамическое выделение памяти для двумерных массивов выполняется практически так же, как и для одномерных. Сначала выделяем память под **внешний** массив, а затем в цикле выделяем память для каждого **внутреннего** массива. Пример:
```C
#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows_count = 0;
    int cols_count = 0;

    scanf("%d %d", &rows_count, &cols_count);

    // Выделяем память для внешнего массива. Т.к. тип переменной массива - это указатель
    // (например, для массива целых чисел - int*), а внешний массив содержит внутренние массивы,
    // то для вычисления размера внешнего массива необходимо перемножить размер указателя на 
    // внутренний массив (в байтах) на размер внешнего массива
    int **matrix = malloc(rows_count * sizeof(int*));

    // Далее выделяем память для внутренних массивов
    for (int i = 0; i < rows_count; i++) {
        matrix[i] = malloc(cols_count * sizeof(int));
    }

    // Ввод двумерного массива
    for (int i = 0; i < rows_count; i++)
    {
        for (int j = 0; j < cols_count; j++)
        {
            printf("Matrix[%d][%d] = ", i, j);
            scanf("%d", &matrix[i][j]);
        }
    }

    // Вывод двумерного массива в табличном виде
    printf("Matrix elements:\n");
    for (int i = 0; i < rows_count; i++)
    {
        for (int j = 0; j < cols_count; j++)
        {
            printf("|%-5d", matrix[i][j]);
        }
        printf("|\n");
    }

    // Операции с двумерными массивами выполняются аналогично с одномерными
    matrix[3][1] = 15;

    // Можно переставлять строки следующим образом
    // (например, строку с индексом 3 меняем с последней)
    int *tmp_array = matrix[3];            // сохраняем строку с инд. 3 в переменную-буфер
    matrix[3] = matrix[rows_count - 1];    // строку с инд. 3 заменяем на последнюю строку
    matrix[rows_count - 1] = tmp_array;    // а последнюю строку заменяем на строку 3 (из буфера)

    // После завершения работы с двумерным массивом обязательно 
    // освобождаем память. Сначала в цикле освобождаем память, 
    // выделенную для внутренних массивов
    for (int i = 0; i < rows_count; i++)
    {
        free(matrix[i]);
    }
    
    // А затем освобождаем память, выделенную для внешнего массива
    free(matrix);
    
    return 0;
}
```

#### Перенаправление потока ввода
Небольшой лайфхак с входными данными для программы, чтобы не вводить их раз за разом.

Создайте текстовый файл, который содержит все входные данные к программе. Например, у вас программа поочередно запрашивает количество столбцов, количество строк, а затем элементы массива:
```C
    int N, M = 0;

    int matrix[30][10];

    scanf("%d %d", &N, &M);

    // Ввод матрицы
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            scanf("%d", &matrix[i][j]);
        }
    }
```
Тогда содержимое файла будет следующим:
```txt
5 3
1 2 3
4 5 6
3 7 8
1 2 4
2 2 2
```

Далее скомпилируйте программу. Откройте в проводнике папку, где лежит скомпилированный исполняемый файл (`.exe`) и нажмите курсором туда, куда показывает стрелка на скрине (именно на пустое место). Напишите `cmd` и нажмите `Enter`. Откроется консоль в той же папке.

<p align="center">
  <img src="./img/README-7.png" alt="README-1.png" width="30%">
</p>

Далее в консоли напишите название исполняемого файла, оператор `<` и название файла с входными данными. Все это разделено пробелом. Пример:
```
main.exe < test_data.txt
```
Оператор `<` - это перенаправление потока ввода. Т.е. ваша программа в таком случае получит данные не с клавиатуры, а из файла. И таким образом можете создать несколько файлов с тестовыми данными и так гонять их, не затрачивая время на постоянный ручной ввод.