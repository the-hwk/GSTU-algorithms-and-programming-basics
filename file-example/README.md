## Пример чтения бинарного файла

**Что такое бинарный файл**

Бинарный файл - это файл, содержащий данные в том виде, в каком они представлены в памяти компьютера, то есть в виде последовательности байтов. В отличие от текстовых файлов, бинарные не предназначены для чтения человеком - они хранят данные без преобразования в символы. 

Благодаря этому бинарные файлы удобны для хранения структур в языке *C*, так как данные в структуре записываются в файл и считываются из него "как есть", без необходимости разбирать строковое представление.

Когда мы записываем структуру в бинарный файл, мы копируем её побайтово из оперативной памяти в файл. Когда мы загружаем структуру из файла, то восстанавливаем её в том же виде, как она была записана.

**Функции для работы с бинарными файлами в языке *C***

В *C* для работы с файлами используется функция `fopen`. Она открывает файл и возвращает указатель на структуру `FILE`, с помощью которой выполняется дальнейшая работа с файлом. Функция `fopen` принимает два аргумента: имя файла (строка) и режим открытия (тоже строка). Например, `"rb"` означает "открыть файл для чтения в бинарном режиме", а `"wb"` - "открыть для записи в бинарном режиме". Если файл открыть не удалось (например, он не существует при попытке чтения), `fopen` возвращает `NULL`.

Для записи данных в бинарный файл используется функция `fwrite`. Её прототип:

```c
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
```

Она записывает `count` элементов, каждый размером `size` байт, из памяти, на которую указывает `ptr`, в файл `stream`. Возвращаемое значение - количество успешно записанных элементов.

Аналогично, для чтения используется `fread`:

```c
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
```

Она читает `count` элементов по `size` байт каждый из файла `stream` в область памяти, на которую указывает `ptr`. Функция возвращает количество успешно прочитанных элементов.

После окончания работы с файлом его необходимо закрыть. Для этого используется функция `fclose`, которая в качестве входного параметра принимает указатель на структуру `FILE`.

**Немного кода**

Пусть задана коллекция рекламных объявлений в виде структуры:

```C
/**
 * Коллекция для хранения объявлений
 * @param count Количество объявлений
 * @param elements Массив объектов структур, описывающих объявление
 */
typedef struct {
    int count;
    Advert elements[10];
} AdvertsCollection;
```

Функция для чтения бинарного файла, который содержит эту структуру в виде последовательности байт, выглядит следующим образом:

```C
/**
 * Чтение бинарного файла с коллекцией рекламных объявлений
 * @param filepath Путь к бинарному файлу
 */
AdvertsCollection readFromBinaryFile(char *filepath) {
    // Открываем бинарный файл в режиме чтения
    FILE *file = fopen(filepath, "rb");

    // Проверяем открылся ли файл
    // (условие: если он не открылся)
    if (file == NULL) {
        // Выводим ошибку в стандартный поток ошибок
        perror("Ошибка открытия файла!");
        // Завершаем программу с кодом ошибки 1 (ошибка выполнения)
        exit(EXIT_FAILURE);
    }

    AdvertsCollection collection;

    // Выполняем чтение файла
    fread(&collection, sizeof(AdvertsCollection), 1, file);
    // И закрываем его
    fclose(file);

    return collection;
}
```

Функция для записи структуры в бинарный файл:

```C
/**
 * Запись коллекции рекламных объявлений в бинарный файл
 * @param filepath Путь к бинарному файлу (будет создан новый, если не существует)
 * @param collection Коллекция с рекламными объявлениями
 */
void writeToBinaryFile(char *filepath, AdvertsCollection collection) {
    // Открываем файл для записи
    // Если файла не существует, то он будет создан
    FILE *file = fopen(filepath, "wb");

    // Проверяем открылся ли файл
    // (обычно ошибка бывает, когда файловая система
    // запрещает создание файла)    
    if (file == NULL) {
        perror("Ошибка открытия/создания файла!");
        exit(EXIT_FAILURE);
    }

    // Записываем структуру в файл
    fwrite(&collection, sizeof(AdvertsCollection), 1, file);
    // И закрываем его
    fclose(file);
}
```

Полная программа для работы со структурами и бинарными файлами представлена в файлах:
- `advert.h` - заголовочный файл, содержит прототипы функций и объявления структур;
- `advert.c` - содержит реализации функций, описанных в предыдущем файле;
- `main.c` - точка старта программы.

Для компиляции и сборки программы необходимо выполнить следующую команду:
```
gcc .\main.c .\advert.c -o app
```

При первом запуске попробуйте сразу прочитать бинарный файл (`data.bin`) (пункт 6 в меню). Он уже содержит две записи. После чтения выведите их (пункт 4 в меню).

## Вывод в табличном виде

Для вывода элементов структуры в табличном виде можно сделать следующее.

Создать строковую константу, которая содержит шаблон для вывода элементов структуры:

```C
// Шаблон для вывода элементов структуры
const char *TEMPLATE = "|%2s|%-30s|%-10s|%-10s|%-70s|\n";
```

Примечание:
- `%10s` - ширина поля 10 символов, выравнивание по правому краю;
- `%-15s` - ширина поля 15 символов, выравнивание по левому краю.

Реализовать три функции:
- для вывода шапки таблицы;
- для вывода одного объекта структуры;
- для вывода нескольких объектов структур.

```C
/**
 * Вывод шапки таблицы
 */
void printHead() {
    printf(TEMPLATE, "#", "Customer", "Type", "Date", "Text");
}
```

```C
/**
 * Вывод одного объекта структуры
 * @param advert Объявление
 * @param number Номер (для вывода)
 */
void printAdvert(Advert advert, int number) {
    char *strDate = dateToStr(advert.date);

    // Преобразование номера (числа) в строку
    char strNumber[2];
    sprintf(strNumber, "%d", number);

    printf(TEMPLATE,
        strNumber,
        advert.fullName, 
        typeToStr(advert.type), 
        strDate,
        advert.text);

    free(strDate);
}
```

```C
/**
 * Вывод нескольких объектов структур
 * @param advert Объявление
 * @param number Номер (для вывода)
 */
void printAllAdverts() {
    printHead();

    for (int i = 0; i < db.count; i++) {
        printAdvert(db.elements[i], (i + 1));
    }
}
```